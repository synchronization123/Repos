import os
import pandas as pd
from datetime import datetime
import sys

# Ensure output folder exists
output_folder = "data/output"
os.makedirs(output_folder, exist_ok=True)

# Step 1: Kill dataframe function to clear the dataframe memory
def kill_dataframe(df):
    """ Clears the dataframe memory to avoid fragmentation """
    del df
    return pd.DataFrame()  # return a fresh dataframe

# Step 2: Load and Merge Files
merged_data = []
for file in os.listdir():
    if file.endswith(".xlsx"):
        df = pd.read_excel(file, dtype=str)
        merged_data.append(df)

# Combine all data into a single DataFrame
merged_df = pd.concat(merged_data, ignore_index=True).copy()

# Standardize column names
merged_df.columns = merged_df.columns.str.strip()

# Kill the dataframe to clear any fragments at the beginning
merged_df = kill_dataframe(merged_df)

# Step 3: Reload files into a fresh DataFrame after clearing previous data
merged_data = []
for file in os.listdir():
    if file.endswith(".xlsx"):
        df = pd.read_excel(file, dtype=str)
        merged_data.append(df)

# Combine all data again into a single fresh DataFrame
merged_df = pd.concat(merged_data, ignore_index=True).copy()

# Standardize Issue Type values before modifications
issue_type_mapping = {
    "Bug Security": "Security",
    "Improvement-Technical Security": "Security",
    "Bug": "Functional Bug",
    "Story": "Epic Story"
}

# Apply Issue Type Mapping
merged_df["Issue Type"] = merged_df["Issue Type"].replace(issue_type_mapping)

# Concatenate Issue Type with Security if applicable
if "Security" in merged_df.columns:
    merged_df["Issue Types"] = merged_df[["Issue Type", "Security"]].astype(str).agg(" ".join, axis=1).str.strip()
    merged_df.drop(columns=["Security"], inplace=True)
else:
    merged_df["Issue Types"] = merged_df["Issue Type"]

# Handle NaN values for Issue Types
missing_issue_types_count = merged_df["Issue Types"].isna().sum()

# Step 4: Display summary for missing issue types
if missing_issue_types_count > 0:
    print(f"\n‚ö†Ô∏è Missing or malformed 'Issue Types': {missing_issue_types_count} rows")

# Step 5: Ensure no NaN values in "Issue Types" column
merged_df["Issue Types"].fillna("Missing Issue Type", inplace=True)  # You can also leave it as NaN or "Unknown"

# Convert Date fields
current_date = datetime.now().strftime("%d-%b-%Y")
merged_df["Date"] = current_date
merged_df["Assigned On"] = current_date

# Step 6: Kill the dataframe to avoid fragmentation at this point
merged_df = kill_dataframe(merged_df)

# Step 7: Reload the merged dataframe again fresh to continue processing
merged_data = []
for file in os.listdir():
    if file.endswith(".xlsx"):
        df = pd.read_excel(file, dtype=str)
        merged_data.append(df)

merged_df = pd.concat(merged_data, ignore_index=True).copy()

# Step 8: Summary by Version ‚Üí Issue Type
print("\nüìä Summary by Version:")
version_summary = merged_df.groupby(["Version", "Issue Types"]).size().reset_index(name="Count")
print(version_summary)

# Step 9: Summary by Issue Type
print("\nüìä Summary by Issue Type:")
issue_summary = merged_df["Issue Types"].value_counts().reset_index()
issue_summary.columns = ["Issue Types", "Count"]
print(issue_summary)

# Step 10: User Input & Assignment
issue_type_counts = merged_df["Issue Types"].value_counts()
user_assignment = {}

for issue_type, count in issue_type_counts.items():
    num_users_required = max(1, count // 30)  
    print(f"\nüìù Issue Type: {issue_type} ‚Üí {count} issues found.")
    print(f"Suggested: Enter at least {num_users_required} users (30 issues per user).")

    user_input = input(f"Enter {num_users_required} or more comma-separated users: ").strip()
    users = [u.strip() for u in user_input.split(",") if u.strip()]

    if not users:
        print("‚ö†Ô∏è No users provided. Skipping assignment for this Issue Type.")
        continue

    user_assignment[issue_type] = users

# Step 11: Correct Sequential Assignment Logic
def assign_users(issue_type, df):
    users = user_assignment.get(issue_type, [])
    if not users:
        return df  

    df = df.copy()
    user_count = len(users)
    
    for i in range(len(df)):
        df.at[i, "Assigned To"] = users[i // 30 % user_count]  

    return df

# Apply assignment logic
merged_df["Assigned To"] = ""
for issue_type in user_assignment.keys():
    merged_df.loc[merged_df["Issue Types"] == issue_type, :] = assign_users(issue_type, merged_df[merged_df["Issue Types"] == issue_type])

# Check if 'Assigned To' is updated
if merged_df["Assigned To"].isna().sum() > 0:
    print(f"\n‚ö†Ô∏è There are {merged_df['Assigned To'].isna().sum()} rows with unassigned users.")
else:
    print("\n‚úÖ All rows are correctly assigned to users.")

# Step 12: Summary by Assigned User
print("\nüìä Summary by Assigned User:")
assigned_summary = merged_df["Assigned To"].value_counts().reset_index()
assigned_summary.columns = ["Assigned To", "Count"]
print(assigned_summary)

# Step 13: Split into Develop & Non-Develop
develop_df = merged_df[merged_df["Version"].str.contains("develop", case=False, na=False)].copy()
non_develop_df = merged_df[~merged_df["Version"].str.contains("develop", case=False, na=False)].copy()

# Drop rows with blank Versions in Non-Develop
non_develop_df = non_develop_df[non_develop_df["Version"].notna()]

# Check if the columns "Analyst Comments" and "Mentor Review" exist, else create them with default values
if "Analyst Comments" not in non_develop_df.columns:
    non_develop_df["Analyst Comments"] = ""
if "Mentor Review" not in non_develop_df.columns:
    non_develop_df["Mentor Review"] = ""

# Arrange final columns
final_columns = ["Date", "Issue Key", "Issue Types", "Version", "Assigned To", "Status", "Assigned On", "Analyst Comments", "Mentor Review", "Feedback"]
develop_df = develop_df[final_columns]
non_develop_df = non_develop_df[final_columns]

# Step 14: Save Final Files
develop_file = os.path.join(output_folder, f"Develop_jiras_{datetime.now().strftime('%Y-%m-%d')}.xlsx")
non_develop_file = os.path.join(output_folder, f"Non_Develop_jiras_{datetime.now().strftime('%Y-%m-%d')}.xlsx")

develop_df.to_excel(develop_file, index=False)
non_develop_df.to_excel(non_develop_file, index=False)

# Step 15: Cleanup Files and Kill Script
for file in os.listdir():
    if file.endswith(".xlsx") and file not in [develop_file, non_develop_file]:
        os.remove(file)

# Kill dataframe after completion to free memory
merged_df = kill_dataframe(merged_df)
develop_df = kill_dataframe(develop_df)
non_develop_df = kill_dataframe(non_develop_df)

print("\n‚úÖ Process Completed Successfully!")
print(f"üìÇ Develop File: {develop_file}")
print(f"üìÇ Non-Develop File: {non_develop_file}")

# Kill the script to free memory
sys.exit()